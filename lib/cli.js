// Generated by CoffeeScript 2.0.0-beta9-dev
var $0, $0, additionalArgs, CoffeeScript, concat, cscodegen, e, escodegen, esmangle, foldl, fs, generateHelp, humanReadable, input, input, inputName, inputSource, inspect, numberLines, Optimiser, options, output, parseOptions, path, pkg, positionalArgs, Preprocessor, processInput, Repl, runMain;
fs = require('fs');
path = require('path');
cache$ = require('./functional-helpers');
concat = cache$.concat;
foldl = cache$.foldl;
cache$1 = require('./helpers');
numberLines = cache$1.numberLines;
humanReadable = cache$1.humanReadable;
Preprocessor = require('./preprocessor').Preprocessor;
Optimiser = require('./optimiser').Optimiser;
runMain = require('./run').runMain;
CoffeeScript = require('./module');
Repl = require('./repl');
cache$2 = require('./options');
parseOptions = cache$2.parse;
generateHelp = cache$2.generateHelp;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$1) {
    return;
  }
}.call(this);
esmangle = function () {
  try {
    return require('esmangle');
  } catch (e$2) {
    return;
  }
}.call(this);
inspect = function (o) {
  return require('util').inspect(o, false, 9e9, true);
};
output = function (out) {
  if (options.output) {
    return fs.writeFile(options.output, '' + out + '\n', function (err) {
      if (null != err)
        throw err;
    });
  } else {
    return process.stdout.write('' + out + '\n');
  }
};
try {
  options = parseOptions(process.argv);
  positionalArgs = options._;
} catch (e$3) {
  e = e$3;
  console.error(e.message);
  process.exit(1);
}
if (!(options.compile || options.js || options.sourceMap || options.parse || options['eval'] || options.cscodegen))
  if (!(null != escodegen)) {
    options.compile = true;
  } else if (positionalArgs.length) {
    options['eval'] = true;
    options.input = positionalArgs.shift();
    additionalArgs = positionalArgs;
  } else {
    options.repl = true;
  }
if (null != options.input && fs.statSync(options.input).isDirectory() && (!(null != options.output) || (null != (cache$3 = fs.statSync(options.output)) ? cache$3.isFile() : void 0))) {
  console.error('Error: when --input is a directory, --output must be provided, and --output must not reference a file');
  process.exit(1);
}
if (options.cscodegen && !(null != cscodegen)) {
  console.error('Error: cscodegen must be installed to use --cscodegen');
  process.exit(1);
}
if (options.help) {
  $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
  $0 = path.basename($0);
  console.log(generateHelp({ interpolate: { $0: $0 } }));
} else if (options.version) {
  pkg = require('./../package.json');
  console.log('CoffeeScript version ' + pkg.version);
} else if (options.repl) {
  CoffeeScript.register();
  process.argv.shift();
  Repl.start();
} else {
  input = '';
  inputName = null != options.input ? options.input : options.cli && 'cli' || 'stdin';
  inputSource = null != options.input ? fs.realpathSync(options.input) : options.cli && '(cli)' || '(stdin)';
  processInput = function (err) {
    var cache$4, js, jsAST, preprocessed, result, sourceMap, sourceMappingUrl;
    if (null != err)
      throw err;
    result = null;
    input = input.toString();
    if (65279 === input.charCodeAt(0))
      input = input.slice(1);
    if (options.debug)
      try {
        console.error('### PREPROCESSED CS ###');
        preprocessed = Preprocessor.process(input, { literate: options.literate });
        console.error(numberLines(humanReadable(preprocessed)));
      } catch (e$4) {
      }
    try {
      result = CoffeeScript.parse(input, {
        optimise: false,
        raw: options.raw || options.sourceMap || options.sourceMapFile || options['eval'],
        inputSource: inputSource,
        literate: options.literate
      });
    } catch (e$5) {
      e = e$5;
      console.error(e.message);
      process.exit(1);
    }
    if (options.debug && options.optimise && null != result) {
      console.error('### PARSED CS-AST ###');
      console.error(inspect(result.toBasicObject()));
    }
    if (options.optimise && null != result)
      result = Optimiser.optimise(result);
    if (options.parse)
      if (null != result) {
        output(inspect(result.toBasicObject()));
        return;
      } else {
        process.exit(1);
      }
    if (options.debug && null != result) {
      console.error('### ' + (options.optimise ? 'OPTIMISED' : 'PARSED') + ' CS-AST ###');
      console.error(inspect(result.toBasicObject()));
    }
    if (options.cscodegen) {
      try {
        result = cscodegen.generate(result);
      } catch (e$6) {
        e = e$6;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != result) {
        output(result);
        return;
      } else {
        process.exit(1);
      }
    }
    jsAST = CoffeeScript.compile(result, { bare: options.bare });
    if (options.compile)
      if (null != jsAST) {
        output(inspect(jsAST));
        return;
      } else {
        process.exit(1);
      }
    if (options.debug && null != jsAST) {
      console.error('### COMPILED JS-AST ###');
      console.error(inspect(jsAST));
    }
    if (options.minify)
      try {
        jsAST = esmangle.mangle(esmangle.optimize(jsAST), { destructive: true });
      } catch (e$7) {
        e = e$7;
        console.error(e.stack || e.message);
        process.exit(1);
      }
    if (options.sourceMap) {
      try {
        sourceMap = CoffeeScript.sourceMap(jsAST, inputName, { compact: options.minify });
      } catch (e$8) {
        e = e$8;
        console.error(e.stack || e.message);
        process.exit(1);
      }
      if (null != sourceMap) {
        output('' + sourceMap);
        return;
      } else {
        process.exit(1);
      }
    }
    try {
      cache$4 = CoffeeScript.jsWithSourceMap(jsAST, inputName, { compact: options.minify });
      js = cache$4.code;
      sourceMap = cache$4.map;
      cache$4;
    } catch (e$9) {
      e = e$9;
      console.error(e.stack || e.message);
      process.exit(1);
    }
    if (options.js) {
      if (options.sourceMapFile) {
        fs.writeFileSync(options.sourceMapFile, '' + sourceMap);
        sourceMappingUrl = options.output ? path.relative(path.dirname(options.output), options.sourceMapFile) : options.sourceMapFile;
        js = '' + js + '\n\n//# sourceMappingURL=' + sourceMappingUrl + '';
      }
      output(js);
      return;
    }
    if (options['eval']) {
      CoffeeScript.register();
      process.argv = [
        process.argv[1],
        options.input
      ].concat(additionalArgs);
      runMain(input, js, jsAST, inputSource);
      return;
    }
  };
  if (null != options.input) {
    fs.stat(options.input, function (err, stats) {
      if (null != err)
        throw err;
      if (stats.isDirectory())
        options.input = path.join(options.input, 'index.coffee');
      return fs.readFile(options.input, function (err, contents) {
        if (null != err)
          throw err;
        input = contents;
        return processInput();
      });
    });
  } else if (null != options.watch) {
    options.watch;
  } else if (null != options.cli) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function (data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}
